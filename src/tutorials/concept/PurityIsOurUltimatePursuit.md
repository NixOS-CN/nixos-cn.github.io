# 纯净是我们的至高追求

## 整个构建系统并不是绝对纯净

我们前面一直在强调，NixOS 的生态系统有多函数式，好吧的确是有非常多的函数，但是这
些函数似乎并不纯净。这些都要从整个函数机器的齿轮 —— Nix 文件说起。

为了设计一个纯净的函数，我们应该尽量地把它设计得封闭，使之隔离外部环境。但是 Nix
并不是这样，Nix 为了编译那些 Nix 文件，依然需要访问到外部世界的东西。

::: tip Nix 文件可以访问任意文件（如 `~/.config/nixpkgs/config.nix`）、环境变
量、Git仓库、Nix搜索路径（`$NIX_PATH`）中的文件、命令行参数（`--arg`）以及系统类
型（`builtins.currentSystem`）。:::

这就意味着这个函数的求值过程并不完全封闭。如果你在两台不同的机器上运行相同的 Nix
表达式，可能会得到不同的结果，因为这两台机器上的环境变量或文件系统可能是不同
的。==所以我们建议尽量避开任何带有路径依赖的写法。==

但是这样做并不能完全解决问题，因为 Nix 文件本身就是一个路径依赖（当你使用 import
函数来引入其他 Nix 文件时，你必须指定一个相对或绝对路径）这就导致了一个问题：如
果你想把你的 Nix 项目分享给别人，你必须保证他们能够找到你引用的所有文件。这就需
要你把所有相关的文件都打包成一个压缩文件或者上传到一个 Git 仓库，并且告诉别人如
何正确地使用它们。

这显然是很麻烦的，而且也违背了函数式编程的原则。==我们希望能够用一种更简单和优雅
的方式来管理和共享我们的 Nix 项目，而不需要关心它们所依赖的具体路径。==

## 我们好像漏掉了什么细节

在前面的章节中，我们还一直试图给阅读者灌输 “NixOS” 只要靠配置文件就能复现系统的
理念？但是事实果真是这样吗，让我们回溯一下：不变的函数之所以能有不变的输出，是因
为有不变的输入。==输入果真是一成不变的吗？==

我们以最大的输入 pkgs 举例，这个输入指代的是 Nix 包管理器的软件仓库 Nixpkgs，里
面有数不尽的包（Nixpkgs 是事实上最大的单体包仓库）日日夜夜在提交与修改，导致
nixpkgs 一直处于 unstable 状态。与之俱来的是 options 也经常变动，这意味着你的配
置文件可能对旧版包是生效的，但是新版包的 options 变动了，现在又无效了。

你会如何解决这个由依赖版本与配置不匹配的问题呢？答案是现在很多语言的包管理（比如
Cargo，pnpm）都采用的版本锁定。本网站的就是被 pnpm 管理着依赖，你可以访问本站源
代码仓库，根目录下有个叫做 `pnpm-lock.yaml` 的文件，里面描述了各依赖互相兼容的版
本。每次更新依赖时，==包管理器会在尽可能让依赖版本比较新的条件下保持最大兼容==，
并更新 Lock 文件。

于是我们怀着两个需求：

- 尽量排除 Nix 文件互相引用时对本地文件系统路径的依赖
- 控制输入的版本，从而达到输出的可预期性
- 将 Nix 项目组织成一种易管理的形式

于是 Flakes 诞生了！

## 终极解决方案 Flakes

Flakes 是 Nix 2.4 版本引入的一个新特性，它可以让你用一种声明式和纯净的方式来定义
和使用 Nix 项目。Flakes 使用了一种 Flake 引用的方式来代替文件系统路径，URL
等。Flake 引用大致就是下面的用法：

- 类 URL 句法，例如 `github:NixOS/nixpkgs` 表示 Github 托管平台上一个叫做
  `NixOS` 用户的 `nixpkgs` 仓库。这与裸 URL 不同，要是哪天 Github 域名搬家了，也
  不用你批量替换 URL，只需要等 Nix 更新 Flakes 引用的解析规则就成。

- 类路径句法，比如 `/absolute/path/to/the/Flakes` 和
  `./relative/path/to/the/Flakes`。你可能就会疑惑，这不就是平时的相对路径与绝对
  路径写法吗，究竟“类”在哪里了呢？“类”在这种引用既可能指向一个本地文件系统路径，
  也可能指向一个本地 Git 仓库。如果你的 URL 指向一个本地的 Git 仓库，它就会在
  `flake.lock` 里面记录当前仓库的 commit hash，这就保证了输入的版本是不变的。那
  你又问，万一我要引入的目录没有版本控制呢？那我只能说你自己人工去保证输入的这个
  目录的内容是不变的吧。

为了保证输入的可获取性，我们一般用网络上的仓库作为输入，因为只要有网络，我们就能
获得相同的输入。而使用本地文件系统路径作为输入则不然，我们很难保证每台主机的相应
文件系统路径下都有一样的文件。因此，我们的建议是更多地依赖网络上的输入，除非你有
一些隐私信息，才有必要使用本地文件系统输入。

```nix
{
  description = "A simple Flakes";

  inputs.nixpkgs.url = "github:NixOS/nixpkgs/nixos-unstable";

  outputs = { self, nixpkgs }: {
    packages.x86_64-linux.hello =
      with nixpkgs.legacyPackages.x86_64-linux;
      stdenv.mkDerivation {
        name = "hello";
        src = hello.src;
        buildInputs = [ gcc ];
        installPhase = ''
          mkdir -p $out/bin
          echo "Hello, world!" > $out/bin/hello
          chmod +x $out/bin/hello
        '';
      };
  };
}
```

## 钉住版本

当你在 `Flakes.nix` 文件中指定了一个 Flakes引用（例如
`github:NixOS/nixpkgs/nixos-unstable`）后，Nix会在第一次运行 `nix build` 或其他
Nix 命令时会生成一个 `flake.lock` 文件。这个文件会记录下所有输入 Flakes 的具体版
本（例如，Git 提交哈希）。有了版本锁，你什么时候构建，都是会根据 `flake.lock` 文
件来确认依赖版本，使得构建结果也与之前并无二致。

如果你想更新到最新的提交，你可以运行 `nix flake update` 命令。这个命令会去更新输
入，并重新钉住最新输入的版本
