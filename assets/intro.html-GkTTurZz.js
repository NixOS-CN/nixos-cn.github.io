import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as p,c,a as n,b as s,d as t,e}from"./app-11f86wUZ.js";const l="/images/Module/ModulesEval.svg",u={},d=e(`<h1 id="nix-的模块系统" tabindex="-1"><a class="header-anchor" href="#nix-的模块系统"><span>Nix 的模块系统</span></a></h1><p>NixOS 的配置文件是通过一个个可复用的模块实现的，我们之前说过一个 Nix 文件就可以是一个函数，你可以在里面写任意表达式，求值这个 Nix 文件都会有输出。<mark>但是不是每一个 Nix 文件都是一个模块，因为模块对格式有特殊要求。</mark></p><h2 id="模块的工作原理" tabindex="-1"><a class="header-anchor" href="#模块的工作原理"><span>模块的工作原理</span></a></h2><p>一个成熟的模块大概由三个部分组成：导入（imports）、选项（options）与配置（config，或者叫做定义）。下面是个简单的示例，请你将这三部分单独看待：</p><div class="language-nix line-numbers-mode" data-ext="nix" data-title="nix"><pre class="language-nix"><code><span class="token punctuation">{</span>
  imports <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token comment"># 这里导入其他模块</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
  options <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment"># 这里声明选项供其他模块设置</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  config <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment"># 选项被激活以后进行的动作</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们先把 <code>imports</code> 数组撇一边去，先观察 <code>options</code> 与 <code>config</code>，两行注释还不足以诠释具体操作，我们直接上例子：</p><div class="language-nix line-numbers-mode" data-ext="nix" data-title="nix"><pre class="language-nix"><code><span class="token punctuation">{</span> config<span class="token punctuation">,</span> pkgs<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">:</span>  <span class="token comment"># 这些参数由构建系统自动输入，你先别管</span>

<span class="token punctuation">{</span>
    <span class="token comment">/*
    我们开始在下面的 options 属性集中声明这个模块的选项了，
    你可以将模块声明成你任意喜欢的名字，这里示例用 “myModule”，注意小驼峰规范。
    同时请注意一件事，那就是模块名称只取决于现在你在 options 的命名，而不是该模块的文件名，
    我们将模块命名与文件名一致也是出于直观？
    */</span>

    options <span class="token operator">=</span> <span class="token punctuation">{</span>
        myModule<span class="token punctuation">.</span>enable <span class="token operator">=</span> mkOption <span class="token punctuation">{</span>
        type <span class="token operator">=</span> types<span class="token punctuation">.</span>bool<span class="token punctuation">;</span>  <span class="token comment"># 此选项的类型是布尔类型</span>
        default <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment"># 默认情况下，此选项被禁用</span>
        description <span class="token operator">=</span> <span class="token string">&quot;描述一下这个模块&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    config <span class="token operator">=</span> mkIf config<span class="token punctuation">.</span>myModule<span class="token punctuation">.</span>enable <span class="token punctuation">{</span>
        systemd<span class="token punctuation">.</span>services<span class="token punctuation">.</span>myService <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment"># 创建新的 systemd 服务</span>
        wantedBy <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;multi-user.target&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment"># 此服务希望在多用户目标下启动</span>
        script <span class="token operator">=</span> <span class="token string">&#39;&#39;  # 服务启动时运行此脚本
                echo &quot;Hello, NixOS!&quot;
            &#39;&#39;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上面的代码中，我们通过向 <code>mkOption</code> 函数传递了一个属性集生成了一个布尔选项，下面的 <code>mkIf</code> 则生成第一个参数为 <code>true</code> 才执行的动作。</p>`,8),r={class:"hint-container tip"},m=n("p",{class:"hint-container-title"},"提示",-1),k={href:"https://nixos-cn.org/tutorials/lang/Utils.html",target:"_blank",rel:"noopener noreferrer"},v=e(`<p>好的，现在我们办成了两件事，声明选项，以及定义了启用选项后会触发的动作。不知道你是否足够细心？注意到 <code>mkIf</code> 后面是 <code>config.myModule.enable</code>，即它是从参数 <code>config</code> 输入来的，我们不是在 <code>options</code> 里声明过这个选项了吗？为什么不直接通过 <code>options.myModule.enable</code> 来求值呢？</p><p>直接去求值 <code>options.myModule.enable</code> 是没有意义的，因为这个选项是未经设置的，这只会求值出它的默认值。接下来就是 <code>imports</code> 的作用了，我们通过将一个模块导入到另一个模块，从而在其他模块设置（定义）被包含的模块的 <code>options</code>。</p><p><mark>被包含的模块只有 <code>options</code> 是对外部可见的</mark>，里面定义的函数与常量都是在本地作用域定义的，对其他文件不可见。同时，被 <code>imports</code> 组织的模块集合中的任意模块都能访问任意模块的 <code>options</code>，也就是说，只要是被 <code>imports</code> 组织的模块，其 <code>options</code> 是全局可见的。</p><p>接下来构建系统会提取你所有模块中的 <code>options</code>，然后求值所有模块中对 <code>options</code> 的定义：</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果一个模块没有任何声明，就直接开始定义（<code>config</code>）部分。注意不需要使用 <code>config = {}</code> 包装，因为这个模块不包含任何声明，只有定义。你可以将这里的定义理解为一种无条件配置，因为我们没有使用 <code>mkIf</code> 之类的函数。</p></div><div class="language-nix line-numbers-mode" data-ext="nix" data-title="nix"><pre class="language-nix"><code><span class="token punctuation">{</span>
  imports <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token url">./myModule.nix</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
  myModule<span class="token punctuation">.</span>enable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+`" alt="求值过程" tabindex="0" loading="lazy"><figcaption>求值过程</figcaption></figure><p>然后构建系统再将所有的配置项（即被定义后的 <code>options</code>）求值，然后作为参数 <code>config</code> 输入到每个模块，这就是每个模块通常要在第一行输入 <code>config</code> 的原因，然后下面的 <code>config</code> 会根据最终值触发一系列配置动作，从而达到求值模块以生成系统目的。</p><h2 id="模块的常见输入" tabindex="-1"><a class="header-anchor" href="#模块的常见输入"><span>模块的常见输入</span></a></h2><table><thead><tr><th style="text-align:center;">参数名</th><th style="text-align:left;">描述</th></tr></thead><tbody><tr><td style="text-align:center;"><code>config</code></td><td style="text-align:left;">所有 <code>option</code> 的最终值</td></tr><tr><td style="text-align:center;"><code>lib</code></td><td style="text-align:left;">nixpkgs 提供的库</td></tr><tr><td style="text-align:center;"><code>pkgs</code></td><td style="text-align:left;">nixpkgs 提供的包集合</td></tr><tr><td style="text-align:center;"><code>options</code></td><td style="text-align:left;">所有模块声明的选项</td></tr><tr><td style="text-align:center;"><code>specialArgs</code></td><td style="text-align:left;">特殊参数</td></tr><tr><td style="text-align:center;"><code>utils</code></td><td style="text-align:left;">工具库</td></tr><tr><td style="text-align:center;"><code>modulesPath</code></td><td style="text-align:left;">模块路径</td></tr></tbody></table><h2 id="模块的组织方案" tabindex="-1"><a class="header-anchor" href="#模块的组织方案"><span>模块的组织方案</span></a></h2><p>由于 <code>options</code> 是全局可见的，所以我们需要一种规范组织模块，区分模块的声明与定义部分，不然一切都会被搞砸的。并且尽量不要在零散的地方定义其他模块的 <code>options</code>，这样会让模块的维护异常困难，还可能触发难以想象的副作用。</p><p>我们只让模块声明属于自己职能的部分，一个模块只完成它应该干的一件事。举个简单的例子，现在有两个模块，对于 <code>a.nix</code>，我们将它放到 <code>services</code> 文件夹下。你可以注意下面模块名，这表示了从属关系：</p><div class="language-nix line-numbers-mode" data-ext="nix" data-title="nix"><pre class="language-nix"><code><span class="token punctuation">{</span> config<span class="token punctuation">,</span> lib<span class="token punctuation">,</span> pkgs<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">:</span>

<span class="token punctuation">{</span>
  options<span class="token punctuation">.</span>services<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token punctuation">{</span>
    enable <span class="token operator">=</span> lib<span class="token punctuation">.</span>mkEnableOption <span class="token string">&quot;service a&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  config <span class="token operator">=</span> lib<span class="token punctuation">.</span>mkIf config<span class="token punctuation">.</span>services<span class="token punctuation">.</span>a<span class="token punctuation">.</span>enable <span class="token punctuation">{</span>
    <span class="token comment"># 模块 a 的实现</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>./b.nix</code>：</p><div class="language-nix line-numbers-mode" data-ext="nix" data-title="nix"><pre class="language-nix"><code><span class="token punctuation">{</span> config<span class="token punctuation">,</span> lib<span class="token punctuation">,</span> pkgs<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">:</span>

<span class="token punctuation">{</span>
  imports <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token url">./services/a.nix</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment"># 导入模块 a</span>

  options<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token punctuation">{</span>
    enable <span class="token operator">=</span> lib<span class="token punctuation">.</span>mkEnableOption <span class="token string">&quot;service b&quot;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  config <span class="token operator">=</span> lib<span class="token punctuation">.</span>mkIf config<span class="token punctuation">.</span>b<span class="token punctuation">.</span>enable <span class="token punctuation">{</span>
    services<span class="token punctuation">.</span>a<span class="token punctuation">.</span>enable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment"># 不要这么做</span>
    <span class="token comment"># 模块 b 的实现</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><mark>b 模块不能这样写</mark>。假如我们定义 <code>b.enable = true</code>，则带来了 <code>services.a.enable = true</code> 的副作用，而模块自治的写法是删掉 b 模块中启用 a <code>option</code> 的语句，然后再更加顶层的一个中心文件完成所有模块的 <code>options</code> 的定义。</p><div class="language-nix line-numbers-mode" data-ext="nix" data-title="nix"><pre class="language-nix"><code><span class="token punctuation">{</span> config<span class="token punctuation">,</span> lib<span class="token punctuation">,</span> pkgs<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">:</span>

<span class="token punctuation">{</span>
  imports <span class="token operator">=</span> <span class="token punctuation">[</span>
      <span class="token url">./a.nix</span>
      <span class="token url">./b.nix</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment"># 导入模块 a 和 b</span>

  services<span class="token punctuation">.</span>a<span class="token punctuation">.</span>enable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment"># 在系统配置中启用模块 a</span>
  b<span class="token punctuation">.</span>enable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment"># 在系统配置中启用模块 b</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们在上面的文件上定义这些 <code>options</code> ，正如我们在 <code>/etc/nixos/configuration.nix</code> 所做的一致。综上，我们应该使用<mark>无副作用的组合</mark>来组织模块，并在统一的模块中定义所有模块的 <code>options</code>。</p><h2 id="默认的导入模块" tabindex="-1"><a class="header-anchor" href="#默认的导入模块"><span>默认的导入模块</span></a></h2>`,20),b=n("code",null,"/etc/nixos/configuration.nix",-1),g=n("code",null,"options",-1),x={href:"https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/module-list.nix",target:"_blank",rel:"noopener noreferrer"},h=n("h2",{id:"如何找到-options",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#如何找到-options"},[n("span",null,"如何找到 Options")])],-1),f=n("p",null,[s("安装系统的时候，我们也仅仅是将教程上的 options 抄下来或者根据已有的模板微调就形成了基本的配置。但是该从何处才能查询到 NixOS 提供的更多 "),n("code",null,"Options"),s(" 呢？")],-1),y=n("p",null,[s("答案是本站头顶上检索工具里的 "),n("code",null,"Options"),s(" 检索工具，这个工具是官方在维护。")],-1);function _(N,O){const a=i("ExternalLinkIcon");return p(),c("div",null,[d,n("div",r,[m,n("p",null,[s("这些工具函数可以在"),n("a",k,[s("函数库"),t(a)]),s("查询到。")])]),v,n("p",null,[s("我们在平时修改 "),b,s(" 时，发现我们能定义一些“不存在”的模块的 "),g,s("，它们并不是不存在，而是被默认导入了，你可以点击"),n("a",x,[s("这里"),t(a)]),s("查看默认导入的模块列表。")]),h,f,y])}const q=o(u,[["render",_],["__file","intro.html.vue"]]),E=JSON.parse('{"path":"/tutorials/module-system/intro.html","title":"Nix 的模块系统","lang":"zh-CN","frontmatter":{"description":"Nix 的模块系统 NixOS 的配置文件是通过一个个可复用的模块实现的，我们之前说过一个 Nix 文件就可以是一个函数，你可以在里面写任意表达式，求值这个 Nix 文件都会有输出。但是不是每一个 Nix 文件都是一个模块，因为模块对格式有特殊要求。 模块的工作原理 一个成熟的模块大概由三个部分组成：导入（imports）、选项（options）与配置...","head":[["meta",{"property":"og:url","content":"https://nixos-cn.github.io/tutorials/module-system/intro.html"}],["meta",{"property":"og:site_name","content":"NixOS 中文"}],["meta",{"property":"og:title","content":"Nix 的模块系统"}],["meta",{"property":"og:description","content":"Nix 的模块系统 NixOS 的配置文件是通过一个个可复用的模块实现的，我们之前说过一个 Nix 文件就可以是一个函数，你可以在里面写任意表达式，求值这个 Nix 文件都会有输出。但是不是每一个 Nix 文件都是一个模块，因为模块对格式有特殊要求。 模块的工作原理 一个成熟的模块大概由三个部分组成：导入（imports）、选项（options）与配置..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://nixos-cn.github.io/images/Module/ModulesEval.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-05T13:58:51.000Z"}],["meta",{"property":"article:author","content":"NixOS-CN"}],["meta",{"property":"article:modified_time","content":"2024-07-05T13:58:51.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Nix 的模块系统\\",\\"image\\":[\\"https://nixos-cn.github.io/images/Module/ModulesEval.svg\\"],\\"dateModified\\":\\"2024-07-05T13:58:51.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"NixOS-CN\\",\\"url\\":\\"https://github.com/nixos-cn\\"}]}"]]},"headers":[{"level":2,"title":"模块的工作原理","slug":"模块的工作原理","link":"#模块的工作原理","children":[]},{"level":2,"title":"模块的常见输入","slug":"模块的常见输入","link":"#模块的常见输入","children":[]},{"level":2,"title":"模块的组织方案","slug":"模块的组织方案","link":"#模块的组织方案","children":[]},{"level":2,"title":"默认的导入模块","slug":"默认的导入模块","link":"#默认的导入模块","children":[]},{"level":2,"title":"如何找到 Options","slug":"如何找到-options","link":"#如何找到-options","children":[]}],"git":{"createdTime":1711466486000,"updatedTime":1720187931000,"contributors":[{"name":"Ryan Yin","email":"xiaoyin_c@qq.com","commits":3},{"name":"Tatooi Noyo","email":"tatooi.noyo@outlook.com","commits":2}]},"readingTime":{"minutes":5.45,"words":1635},"filePathRelative":"tutorials/module-system/intro.md","localizedDate":"2024年3月26日","autoDesc":true,"excerpt":"\\n<p>NixOS 的配置文件是通过一个个可复用的模块实现的，我们之前说过一个 Nix 文件就可以是一个函数，你可以在里面写任意表达式，求值这个 Nix 文件都会有输出。<mark>但是不是每一个 Nix 文件都是一个模块，因为模块对格式有特殊要求。</mark></p>\\n<h2>模块的工作原理</h2>\\n<p>一个成熟的模块大概由三个部分组成：导入（imports）、选项（options）与配置（config，或者叫做定义）。下面是个简单的示例，请你将这三部分单独看待：</p>\\n<div class=\\"language-nix\\" data-ext=\\"nix\\" data-title=\\"nix\\"><pre class=\\"language-nix\\"><code><span class=\\"token punctuation\\">{</span>\\n  imports <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">[</span>\\n    <span class=\\"token comment\\"># 这里导入其他模块</span>\\n  <span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">;</span>\\n  options <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\"># 这里声明选项供其他模块设置</span>\\n  <span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n  config <span class=\\"token operator\\">=</span> <span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\"># 选项被激活以后进行的动作</span>\\n  <span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>"}');export{q as comp,E as data};
