import{_ as c}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as s,c as d,a as e,b as i,d as o,e as a}from"./app-9aa4e472.js";const l="/images/Concept/Apt.svg",p="/images/Concept/Portage.svg",g="/images/Concept/HashPath.svg",u={},h=a('<h1 id="二进制分发与源码分发" tabindex="-1"><a class="header-anchor" href="#二进制分发与源码分发" aria-hidden="true">#</a> 二进制分发与源码分发</h1><p>二进制分发从字面意思上就很容易理解，软件包仓库开放预编译的二进制包，并供包管理器下载并部署到目标主机。</p><p>源码分发则是从各处拉取源码，下载编译，再部署到目标主机。看起来只是将编译步骤挪到了本地进行而已，但却给了软件包部署更多灵活性。</p><h2 id="以-debian-作为二进制分发的例子" tabindex="-1"><a class="header-anchor" href="#以-debian-作为二进制分发的例子" aria-hidden="true">#</a> 以 Debian 作为二进制分发的例子</h2><p>Debian 是 GNU/Linux 世界中采用二进制分发的优秀发行版之一，APT 则是它最流行的包管理器之一。</p><figure><img src="'+l+'" alt="APT包管理器" tabindex="0" loading="lazy"><figcaption>APT包管理器</figcaption></figure><p>为了从远程获取预编译的二进制包，APT 需要从三个地方读取源列表：</p><ul><li><code>/etc/apt/sources.list</code></li><li><code>/etc/apt/sources.list.d/*.list</code></li><li><code>/etc/apt/sources.list.d/*.source</code></li></ul><p>然后访问源列表里面的 URL ，获取软件包的元数据（名称，版本，依赖信息等）。这些元数据通常被存储在 <code>/var/lib/apt/lists/</code>。</p><p>只要有元数据的协助，APT 很快就能推算出你要下载的包依赖哪些其他的包，并从软件包仓库开始下载需要的一揽子软件包。这些包被缓存到 <code>/var/cache/apt/archives/</code>。</p><p>Deb 包里面只会包含二进制文件，以及控制这些二进制文件该释放至何处的描述文件。假如你想对这个软件包搞点个性化定制，自己再克隆源码，修改源码，编译和打包一条龙。<mark>你不能从官方包仓库的软件包直接衍生变体。</mark></p><p>不同的打包方式带来了 Linux 软件包生态的分裂。你从 Debian 系发行版和 RHEL 系发行版就能观察到 “血脉兼容” 的现象。</p>',12),m={class:"hint-container tip"},_=e("p",{class:"hint-container-title"},"提示",-1),b={href:"https://github.com/FabioLolix/LinuxTimeline",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"以-gentoo-作为源码分发的例子",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#以-gentoo-作为源码分发的例子","aria-hidden":"true"},"#"),i(" 以 Gentoo 作为源码分发的例子")],-1),f=e("p",null,[i("Gentoo 似乎是另一个极端。它的包管理器叫做 Portage，它从官方的软件仓库获取的是 ebuild 文件，而这些文件会被缓存到 "),e("code",null,"/var/db/repos/gentoo/"),i(" 下。")],-1),v=e("p",null,"你可以将 ebuild 理解为一种构建软件的脚本。它包含了一些函数和变量，用来指定软件包的元数据、依赖关系、源码地址、编译选项、安装步骤等信息。Portage 会根据 ebuild 中的指令来下载、编译和安装软件包。",-1),k=e("figure",null,[e("img",{src:p,alt:"Portage 包管理器",tabindex:"0",loading:"lazy"}),e("figcaption",null,"Portage 包管理器")],-1),N={href:"https://gitweb.gentoo.org/repo/gentoo.git/tree/app-editors/neovim/neovim-9999.ebuild",target:"_blank",rel:"noopener noreferrer"},P=a(`<p>获取到源码以后，Portage 开始了繁忙的编译流程。它需要读取一些编译变量，而它们在 <code>/etc/portage/make.conf</code> 这个配置文件里。 其中包括全局的 USE 标志、编译选项、镜像源、许可证等。这些变量可以控制 Portage 的功能和性能，也可以根据用户的需求进行优化和定制。</p><p>每一台 Gentoo 主机都可能有不同的编译选项，因此编译出来的产物也不一致，<mark>它们已经是一种变体了</mark>。</p><p>另外，许多人喜欢 Gentoo 的原因就是可以更极致地压榨运行性能。但是频繁的编译是相当耗费时间的。后面 Gentoo 又支持了分布式编译，可以让你的其他电脑分担工作量，不过依然是饮鸠止渴。</p><h2 id="nix-之道" tabindex="-1"><a class="header-anchor" href="#nix-之道" aria-hidden="true">#</a> Nix 之道</h2><p>Nix 是 NixOS 的包管理器，它是跨平台的，可以在 Linux 平台和 Darwin 平台使用。</p><p>二进制分发可以保持包的一致性，使本应正常依赖的包可以正常工作（不过需要包管理器控制版本）；源码分发可以保持包的灵活性，可以自由拓展软件功能，衍生软件变体。有什么办法可以鱼与熊掌兼得呢？</p><p>Nix 则使用一种函数式语言来描述软件包及其依赖关系，每个软件包都被视为一个纯函数的输出，这个输出是 <code>/nix/store/</code> 下一个带有哈希值的目录。</p><p>我明白上面的说法对许多人来说太过抽象，所以我又准备了例子。</p><p><code>/nix/store/</code> 下的哈希路径是根据软件包的表达式（描述打包的 Nix 文件）和构建过程（参与构建的参数）来计算出来的。每个软件包都有一个唯一的标识符，它由一个哈希值和一个包名组成，例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/nix/store/7wzgkjk6l9ng015wnx7dbzq73v4yr97g-nyancat-1.5.2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中，<code>7wzgkjk6l9ng015wnx7dbzq73v4yr97g</code> 是一个 160 位的 SHA-256 哈希值，它是根据软件包的表达式和构建过程的所有输入参数计算出来的。这些输入参数包括：</p><ul><li>源码或二进制文件的 URL 和哈希值</li><li>版本号和包名</li><li>依赖关系和构建工具</li><li>编译命令和参数</li><li>补丁和修改</li><li>元数据和测试</li></ul><p>这些输入参数都会被转换成一个 Nix 语言的表达式，然后被序列化成一个字符串，再用 SHA-256 算法计算出一个哈希值。<mark>这个哈希值可以保证软件包的一致性和可复现性，因为只要输入参数不变，就会得到相同的哈希值和相同的软件包。</mark></p><figure><img src="`+g+'" alt="纯函数：唯一的输入有确定的唯一的输出，函数求值不依赖外部也不影响外部" tabindex="0" loading="lazy"><figcaption>纯函数：唯一的输入有确定的唯一的输出，函数求值不依赖外部也不影响外部</figcaption></figure><p>而哈希路径下的文件夹存放着软件包的所有文件，包括可执行文件、库文件、配置文件、文档文件等。这些文件都存放在 <code>/nix/store/</code> 目录下，而不是在系统的其他目录下，例如 <code>/usr/bin/</code> 或 <code>/bin/</code> 等。<mark>这样每个软件包之间都是隔离的</mark>，管理也是异常方便。</p>',15),L=e("p",null,"即使是这样，还是没有解决编译时间久的问题。于是社区提供了许多缓存构建主机，包管理器会优先从上面下载已有的构建结果。除非访问完了缓存主机列表也没找到需要的二进制缓存，才会自己拉取源码构建。",-1);function y(A,z){const t=n("ExternalLinkIcon"),r=n("Mermaid");return s(),d("div",null,[h,e("div",m,[_,e("p",null,[i("还存在一个 "),e("a",b,[i("Linux 时间线项目"),o(t)]),i("，你可以看到宏观的 Linux 衍生历史。")])]),x,f,v,k,e("p",null,[i("为了让这个解释更生动点，我在"),e("a",N,[i("这里"),o(t)]),i("超链接了一个 ebuild 文件，你可以试图理解其中内容。")]),P,o(r,{id:"mermaid-142",code:"eJyNjzsKwkAURftZxdTCNJYprNyFWKQQEbTRYK2ioPgL+EUHtVAR8Y9oyPjZzLyZZBdGg0Jsku7BPe9wLyEEaSktnVCwmC5E7WHTgjiW5KgMjQp6pyinqVoimlKTWTVD8mGEMI6F4piQCBbDPehLoCtBN0APsB2+70kZmClZR0yow/oyH5Nd0LmxtnZPe7DjZsN6jqF6kbeOg3ODCWoqmBtN9zmQ9GOFW092v8z1JFnbJZ15HljBP7NvEXd4vQbtvjB1OSty1oL52fV5WwZzcaNu3e9/+a/RCzRrAOM="}),L])}const E=c(u,[["render",y],["__file","BinaryAndSourceDistribution.html.vue"]]);export{E as default};
